// This file is generated by rust-protobuf 2.25.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `msg_c_es.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgStartExploreReq {
    // message fields
    pub player_id: u64,
    pub explore_uuid: u64,
    pub access_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgStartExploreReq {
    fn default() -> &'a C2EsMsgStartExploreReq {
        <C2EsMsgStartExploreReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgStartExploreReq {
    pub fn new() -> C2EsMsgStartExploreReq {
        ::std::default::Default::default()
    }

    // uint64 player_id = 1;


    pub fn get_player_id(&self) -> u64 {
        self.player_id
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u64) {
        self.player_id = v;
    }

    // uint64 explore_uuid = 2;


    pub fn get_explore_uuid(&self) -> u64 {
        self.explore_uuid
    }
    pub fn clear_explore_uuid(&mut self) {
        self.explore_uuid = 0;
    }

    // Param is passed by value, moved
    pub fn set_explore_uuid(&mut self, v: u64) {
        self.explore_uuid = v;
    }

    // string access_token = 3;


    pub fn get_access_token(&self) -> &str {
        &self.access_token
    }
    pub fn clear_access_token(&mut self) {
        self.access_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        &mut self.access_token
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for C2EsMsgStartExploreReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.player_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.explore_uuid = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.player_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.player_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.explore_uuid != 0 {
            my_size += ::protobuf::rt::value_size(2, self.explore_uuid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.player_id != 0 {
            os.write_uint64(1, self.player_id)?;
        }
        if self.explore_uuid != 0 {
            os.write_uint64(2, self.explore_uuid)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(3, &self.access_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgStartExploreReq {
        C2EsMsgStartExploreReq::new()
    }

    fn default_instance() -> &'static C2EsMsgStartExploreReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgStartExploreReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgStartExploreReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgStartExploreReq {
    fn clear(&mut self) {
        self.player_id = 0;
        self.explore_uuid = 0;
        self.access_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgStartExploreReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgStartExploreResp {
    // message fields
    pub result: StartExploreResult,
    pub seed: i32,
    pub locate: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    pub target_id: u32,
    pub explored_map: ::std::vec::Vec<i32>,
    pub new_targets: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgStartExploreResp {
    fn default() -> &'a Es2CMsgStartExploreResp {
        <Es2CMsgStartExploreResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgStartExploreResp {
    pub fn new() -> Es2CMsgStartExploreResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.StartExploreResult result = 1;


    pub fn get_result(&self) -> StartExploreResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = StartExploreResult::START_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: StartExploreResult) {
        self.result = v;
    }

    // int32 seed = 2;


    pub fn get_seed(&self) -> i32 {
        self.seed
    }
    pub fn clear_seed(&mut self) {
        self.seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: i32) {
        self.seed = v;
    }

    // .ProtoMsg.Common.Point2 locate = 3;


    pub fn get_locate(&self) -> &super::msg_common::Point2 {
        self.locate.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locate(&mut self) {
        self.locate.clear();
    }

    pub fn has_locate(&self) -> bool {
        self.locate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locate(&mut self, v: super::msg_common::Point2) {
        self.locate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locate(&mut self) -> &mut super::msg_common::Point2 {
        if self.locate.is_none() {
            self.locate.set_default();
        }
        self.locate.as_mut().unwrap()
    }

    // Take field
    pub fn take_locate(&mut self) -> super::msg_common::Point2 {
        self.locate.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 4;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }

    // uint32 target_id = 5;


    pub fn get_target_id(&self) -> u32 {
        self.target_id
    }
    pub fn clear_target_id(&mut self) {
        self.target_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u32) {
        self.target_id = v;
    }

    // repeated int32 explored_map = 6;


    pub fn get_explored_map(&self) -> &[i32] {
        &self.explored_map
    }
    pub fn clear_explored_map(&mut self) {
        self.explored_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_explored_map(&mut self, v: ::std::vec::Vec<i32>) {
        self.explored_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_explored_map(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.explored_map
    }

    // Take field
    pub fn take_explored_map(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.explored_map, ::std::vec::Vec::new())
    }

    // repeated uint32 new_targets = 7;


    pub fn get_new_targets(&self) -> &[u32] {
        &self.new_targets
    }
    pub fn clear_new_targets(&mut self) {
        self.new_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.new_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.new_targets
    }

    // Take field
    pub fn take_new_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.new_targets, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Es2CMsgStartExploreResp {
    fn is_initialized(&self) -> bool {
        for v in &self.locate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seed = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.explored_map)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.new_targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != StartExploreResult::START_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if self.seed != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seed, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.target_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.target_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.explored_map {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.new_targets {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != StartExploreResult::START_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if self.seed != 0 {
            os.write_int32(2, self.seed)?;
        }
        if let Some(ref v) = self.locate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.target_id != 0 {
            os.write_uint32(5, self.target_id)?;
        }
        for v in &self.explored_map {
            os.write_int32(6, *v)?;
        };
        for v in &self.new_targets {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgStartExploreResp {
        Es2CMsgStartExploreResp::new()
    }

    fn default_instance() -> &'static Es2CMsgStartExploreResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgStartExploreResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgStartExploreResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgStartExploreResp {
    fn clear(&mut self) {
        self.result = StartExploreResult::START_SUCCESS;
        self.seed = 0;
        self.locate.clear();
        self.explore_info.clear();
        self.target_id = 0;
        self.explored_map.clear();
        self.new_targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgStartExploreResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CharacterAttribute {
    // message fields
    pub attribute_type: i32,
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CharacterAttribute {
    fn default() -> &'a CharacterAttribute {
        <CharacterAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CharacterAttribute {
    pub fn new() -> CharacterAttribute {
        ::std::default::Default::default()
    }

    // int32 attribute_type = 1;


    pub fn get_attribute_type(&self) -> i32 {
        self.attribute_type
    }
    pub fn clear_attribute_type(&mut self) {
        self.attribute_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_attribute_type(&mut self, v: i32) {
        self.attribute_type = v;
    }

    // int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for CharacterAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attribute_type = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attribute_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.attribute_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attribute_type != 0 {
            os.write_int32(1, self.attribute_type)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CharacterAttribute {
        CharacterAttribute::new()
    }

    fn default_instance() -> &'static CharacterAttribute {
        static instance: ::protobuf::rt::LazyV2<CharacterAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CharacterAttribute::new)
    }
}

impl ::protobuf::Clear for CharacterAttribute {
    fn clear(&mut self) {
        self.attribute_type = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CharacterAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExploreBuff {
    // message fields
    pub buff_id: u32,
    pub battle_buff_id: u32,
    pub count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExploreBuff {
    fn default() -> &'a ExploreBuff {
        <ExploreBuff as ::protobuf::Message>::default_instance()
    }
}

impl ExploreBuff {
    pub fn new() -> ExploreBuff {
        ::std::default::Default::default()
    }

    // uint32 buff_id = 1;


    pub fn get_buff_id(&self) -> u32 {
        self.buff_id
    }
    pub fn clear_buff_id(&mut self) {
        self.buff_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff_id(&mut self, v: u32) {
        self.buff_id = v;
    }

    // uint32 battle_buff_id = 2;


    pub fn get_battle_buff_id(&self) -> u32 {
        self.battle_buff_id
    }
    pub fn clear_battle_buff_id(&mut self) {
        self.battle_buff_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_battle_buff_id(&mut self, v: u32) {
        self.battle_buff_id = v;
    }

    // int32 count = 3;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }
}

impl ::protobuf::Message for ExploreBuff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buff_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.battle_buff_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.buff_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.buff_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.battle_buff_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.battle_buff_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.buff_id != 0 {
            os.write_uint32(1, self.buff_id)?;
        }
        if self.battle_buff_id != 0 {
            os.write_uint32(2, self.battle_buff_id)?;
        }
        if self.count != 0 {
            os.write_int32(3, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExploreBuff {
        ExploreBuff::new()
    }

    fn default_instance() -> &'static ExploreBuff {
        static instance: ::protobuf::rt::LazyV2<ExploreBuff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExploreBuff::new)
    }
}

impl ::protobuf::Clear for ExploreBuff {
    fn clear(&mut self) {
        self.buff_id = 0;
        self.battle_buff_id = 0;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreBuff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExploreCharacterInfo {
    // message fields
    pub id: u32,
    pub state: i32,
    pub attributes: ::protobuf::RepeatedField<CharacterAttribute>,
    pub buff_attrs: ::protobuf::RepeatedField<CharacterAttribute>,
    pub buffs: ::protobuf::RepeatedField<ExploreBuff>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExploreCharacterInfo {
    fn default() -> &'a ExploreCharacterInfo {
        <ExploreCharacterInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExploreCharacterInfo {
    pub fn new() -> ExploreCharacterInfo {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // int32 state = 2;


    pub fn get_state(&self) -> i32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = v;
    }

    // repeated .ProtoMsg.CharacterAttribute attributes = 3;


    pub fn get_attributes(&self) -> &[CharacterAttribute] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<CharacterAttribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<CharacterAttribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<CharacterAttribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    // repeated .ProtoMsg.CharacterAttribute buff_attrs = 4;


    pub fn get_buff_attrs(&self) -> &[CharacterAttribute] {
        &self.buff_attrs
    }
    pub fn clear_buff_attrs(&mut self) {
        self.buff_attrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_buff_attrs(&mut self, v: ::protobuf::RepeatedField<CharacterAttribute>) {
        self.buff_attrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buff_attrs(&mut self) -> &mut ::protobuf::RepeatedField<CharacterAttribute> {
        &mut self.buff_attrs
    }

    // Take field
    pub fn take_buff_attrs(&mut self) -> ::protobuf::RepeatedField<CharacterAttribute> {
        ::std::mem::replace(&mut self.buff_attrs, ::protobuf::RepeatedField::new())
    }

    // repeated .ProtoMsg.ExploreBuff buffs = 5;


    pub fn get_buffs(&self) -> &[ExploreBuff] {
        &self.buffs
    }
    pub fn clear_buffs(&mut self) {
        self.buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffs(&mut self, v: ::protobuf::RepeatedField<ExploreBuff>) {
        self.buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffs(&mut self) -> &mut ::protobuf::RepeatedField<ExploreBuff> {
        &mut self.buffs
    }

    // Take field
    pub fn take_buffs(&mut self) -> ::protobuf::RepeatedField<ExploreBuff> {
        ::std::mem::replace(&mut self.buffs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExploreCharacterInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buff_attrs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buff_attrs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buffs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != 0 {
            my_size += ::protobuf::rt::value_size(2, self.state, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buff_attrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buffs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.state != 0 {
            os.write_int32(2, self.state)?;
        }
        for v in &self.attributes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buff_attrs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buffs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExploreCharacterInfo {
        ExploreCharacterInfo::new()
    }

    fn default_instance() -> &'static ExploreCharacterInfo {
        static instance: ::protobuf::rt::LazyV2<ExploreCharacterInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExploreCharacterInfo::new)
    }
}

impl ::protobuf::Clear for ExploreCharacterInfo {
    fn clear(&mut self) {
        self.id = 0;
        self.state = 0;
        self.attributes.clear();
        self.buff_attrs.clear();
        self.buffs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreCharacterInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExploreItemInfo {
    // message fields
    pub id: u32,
    pub count: i32,
    pub time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExploreItemInfo {
    fn default() -> &'a ExploreItemInfo {
        <ExploreItemInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExploreItemInfo {
    pub fn new() -> ExploreItemInfo {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }

    // int64 time = 3;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }
}

impl ::protobuf::Message for ExploreItemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.count != 0 {
            os.write_int32(2, self.count)?;
        }
        if self.time != 0 {
            os.write_int64(3, self.time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExploreItemInfo {
        ExploreItemInfo::new()
    }

    fn default_instance() -> &'static ExploreItemInfo {
        static instance: ::protobuf::rt::LazyV2<ExploreItemInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExploreItemInfo::new)
    }
}

impl ::protobuf::Clear for ExploreItemInfo {
    fn clear(&mut self) {
        self.id = 0;
        self.count = 0;
        self.time = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreItemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExploreItemPackage {
    // message fields
    pub items: ::protobuf::RepeatedField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExploreItemPackage {
    fn default() -> &'a ExploreItemPackage {
        <ExploreItemPackage as ::protobuf::Message>::default_instance()
    }
}

impl ExploreItemPackage {
    pub fn new() -> ExploreItemPackage {
        ::std::default::Default::default()
    }

    // repeated .ProtoMsg.ExploreItemInfo items = 1;


    pub fn get_items(&self) -> &[ExploreItemInfo] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ExploreItemInfo>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ExploreItemInfo> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ExploreItemInfo> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExploreItemPackage {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExploreItemPackage {
        ExploreItemPackage::new()
    }

    fn default_instance() -> &'static ExploreItemPackage {
        static instance: ::protobuf::rt::LazyV2<ExploreItemPackage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExploreItemPackage::new)
    }
}

impl ::protobuf::Clear for ExploreItemPackage {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreItemPackage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2cMsgExploreCharacters {
    // message fields
    pub characters: ::protobuf::RepeatedField<ExploreCharacterInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2cMsgExploreCharacters {
    fn default() -> &'a Es2cMsgExploreCharacters {
        <Es2cMsgExploreCharacters as ::protobuf::Message>::default_instance()
    }
}

impl Es2cMsgExploreCharacters {
    pub fn new() -> Es2cMsgExploreCharacters {
        ::std::default::Default::default()
    }

    // repeated .ProtoMsg.ExploreCharacterInfo characters = 2;


    pub fn get_characters(&self) -> &[ExploreCharacterInfo] {
        &self.characters
    }
    pub fn clear_characters(&mut self) {
        self.characters.clear();
    }

    // Param is passed by value, moved
    pub fn set_characters(&mut self, v: ::protobuf::RepeatedField<ExploreCharacterInfo>) {
        self.characters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_characters(&mut self) -> &mut ::protobuf::RepeatedField<ExploreCharacterInfo> {
        &mut self.characters
    }

    // Take field
    pub fn take_characters(&mut self) -> ::protobuf::RepeatedField<ExploreCharacterInfo> {
        ::std::mem::replace(&mut self.characters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2cMsgExploreCharacters {
    fn is_initialized(&self) -> bool {
        for v in &self.characters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.characters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.characters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.characters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2cMsgExploreCharacters {
        Es2cMsgExploreCharacters::new()
    }

    fn default_instance() -> &'static Es2cMsgExploreCharacters {
        static instance: ::protobuf::rt::LazyV2<Es2cMsgExploreCharacters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2cMsgExploreCharacters::new)
    }
}

impl ::protobuf::Clear for Es2cMsgExploreCharacters {
    fn clear(&mut self) {
        self.characters.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2cMsgExploreCharacters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2cMsgExploreNewEvent {
    // message fields
    pub x: i32,
    pub y: i32,
    pub type_id: u32,
    pub uuid: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2cMsgExploreNewEvent {
    fn default() -> &'a Es2cMsgExploreNewEvent {
        <Es2cMsgExploreNewEvent as ::protobuf::Message>::default_instance()
    }
}

impl Es2cMsgExploreNewEvent {
    pub fn new() -> Es2cMsgExploreNewEvent {
        ::std::default::Default::default()
    }

    // int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = v;
    }

    // int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = v;
    }

    // uint32 type_id = 3;


    pub fn get_type_id(&self) -> u32 {
        self.type_id
    }
    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: u32) {
        self.type_id = v;
    }

    // uint64 uuid = 4;


    pub fn get_uuid(&self) -> u64 {
        self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: u64) {
        self.uuid = v;
    }
}

impl ::protobuf::Message for Es2cMsgExploreNewEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.type_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uuid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_size(2, self.y, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uuid != 0 {
            my_size += ::protobuf::rt::value_size(4, self.uuid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        if self.type_id != 0 {
            os.write_uint32(3, self.type_id)?;
        }
        if self.uuid != 0 {
            os.write_uint64(4, self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2cMsgExploreNewEvent {
        Es2cMsgExploreNewEvent::new()
    }

    fn default_instance() -> &'static Es2cMsgExploreNewEvent {
        static instance: ::protobuf::rt::LazyV2<Es2cMsgExploreNewEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2cMsgExploreNewEvent::new)
    }
}

impl ::protobuf::Clear for Es2cMsgExploreNewEvent {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.type_id = 0;
        self.uuid = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2cMsgExploreNewEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgNpcInfo {
    // message fields
    pub event_id: u64,
    pub config_id: u32,
    pub state: u32,
    pub position: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    pub path: ::protobuf::RepeatedField<super::msg_common::Point2>,
    pub trigger_state: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgNpcInfo {
    fn default() -> &'a Es2CMsgNpcInfo {
        <Es2CMsgNpcInfo as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgNpcInfo {
    pub fn new() -> Es2CMsgNpcInfo {
        ::std::default::Default::default()
    }

    // uint64 event_id = 1;


    pub fn get_event_id(&self) -> u64 {
        self.event_id
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u64) {
        self.event_id = v;
    }

    // uint32 config_id = 2;


    pub fn get_config_id(&self) -> u32 {
        self.config_id
    }
    pub fn clear_config_id(&mut self) {
        self.config_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_config_id(&mut self, v: u32) {
        self.config_id = v;
    }

    // uint32 state = 3;


    pub fn get_state(&self) -> u32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = v;
    }

    // .ProtoMsg.Common.Point2 position = 4;


    pub fn get_position(&self) -> &super::msg_common::Point2 {
        self.position.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::msg_common::Point2) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::msg_common::Point2 {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::msg_common::Point2 {
        self.position.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }

    // repeated .ProtoMsg.Common.Point2 path = 5;


    pub fn get_path(&self) -> &[super::msg_common::Point2] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<super::msg_common::Point2>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<super::msg_common::Point2> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<super::msg_common::Point2> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    // uint32 trigger_state = 6;


    pub fn get_trigger_state(&self) -> u32 {
        self.trigger_state
    }
    pub fn clear_trigger_state(&mut self) {
        self.trigger_state = 0;
    }

    // Param is passed by value, moved
    pub fn set_trigger_state(&mut self, v: u32) {
        self.trigger_state = v;
    }
}

impl ::protobuf::Message for Es2CMsgNpcInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.config_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trigger_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.event_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.event_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.config_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != 0 {
            my_size += ::protobuf::rt::value_size(3, self.state, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.trigger_state != 0 {
            my_size += ::protobuf::rt::value_size(6, self.trigger_state, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.event_id != 0 {
            os.write_uint64(1, self.event_id)?;
        }
        if self.config_id != 0 {
            os.write_uint32(2, self.config_id)?;
        }
        if self.state != 0 {
            os.write_uint32(3, self.state)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.path {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.trigger_state != 0 {
            os.write_uint32(6, self.trigger_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgNpcInfo {
        Es2CMsgNpcInfo::new()
    }

    fn default_instance() -> &'static Es2CMsgNpcInfo {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgNpcInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgNpcInfo::new)
    }
}

impl ::protobuf::Clear for Es2CMsgNpcInfo {
    fn clear(&mut self) {
        self.event_id = 0;
        self.config_id = 0;
        self.state = 0;
        self.position.clear();
        self.path.clear();
        self.trigger_state = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgNpcInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgExploreSync {
    // message fields
    pub food: i32,
    pub characters: ::protobuf::SingularPtrField<Es2cMsgExploreCharacters>,
    pub new_events: ::protobuf::RepeatedField<Es2cMsgExploreNewEvent>,
    pub package: ::protobuf::SingularPtrField<ExploreItemPackage>,
    pub event_detail: ::protobuf::SingularPtrField<Es2CMsgCurrentEventResp>,
    pub finished_count: u32,
    pub locate: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    pub event_result: i32,
    pub max_food: u32,
    pub consumption: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgExploreSync {
    fn default() -> &'a Es2CMsgExploreSync {
        <Es2CMsgExploreSync as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgExploreSync {
    pub fn new() -> Es2CMsgExploreSync {
        ::std::default::Default::default()
    }

    // int32 food = 1;


    pub fn get_food(&self) -> i32 {
        self.food
    }
    pub fn clear_food(&mut self) {
        self.food = 0;
    }

    // Param is passed by value, moved
    pub fn set_food(&mut self, v: i32) {
        self.food = v;
    }

    // .ProtoMsg.Es2cMsgExploreCharacters characters = 2;


    pub fn get_characters(&self) -> &Es2cMsgExploreCharacters {
        self.characters.as_ref().unwrap_or_else(|| <Es2cMsgExploreCharacters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_characters(&mut self) {
        self.characters.clear();
    }

    pub fn has_characters(&self) -> bool {
        self.characters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_characters(&mut self, v: Es2cMsgExploreCharacters) {
        self.characters = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_characters(&mut self) -> &mut Es2cMsgExploreCharacters {
        if self.characters.is_none() {
            self.characters.set_default();
        }
        self.characters.as_mut().unwrap()
    }

    // Take field
    pub fn take_characters(&mut self) -> Es2cMsgExploreCharacters {
        self.characters.take().unwrap_or_else(|| Es2cMsgExploreCharacters::new())
    }

    // repeated .ProtoMsg.Es2cMsgExploreNewEvent new_events = 3;


    pub fn get_new_events(&self) -> &[Es2cMsgExploreNewEvent] {
        &self.new_events
    }
    pub fn clear_new_events(&mut self) {
        self.new_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_events(&mut self, v: ::protobuf::RepeatedField<Es2cMsgExploreNewEvent>) {
        self.new_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_events(&mut self) -> &mut ::protobuf::RepeatedField<Es2cMsgExploreNewEvent> {
        &mut self.new_events
    }

    // Take field
    pub fn take_new_events(&mut self) -> ::protobuf::RepeatedField<Es2cMsgExploreNewEvent> {
        ::std::mem::replace(&mut self.new_events, ::protobuf::RepeatedField::new())
    }

    // .ProtoMsg.ExploreItemPackage package = 4;


    pub fn get_package(&self) -> &ExploreItemPackage {
        self.package.as_ref().unwrap_or_else(|| <ExploreItemPackage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ExploreItemPackage) {
        self.package = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ExploreItemPackage {
        if self.package.is_none() {
            self.package.set_default();
        }
        self.package.as_mut().unwrap()
    }

    // Take field
    pub fn take_package(&mut self) -> ExploreItemPackage {
        self.package.take().unwrap_or_else(|| ExploreItemPackage::new())
    }

    // .ProtoMsg.Es2CMsgCurrentEventResp event_detail = 5;


    pub fn get_event_detail(&self) -> &Es2CMsgCurrentEventResp {
        self.event_detail.as_ref().unwrap_or_else(|| <Es2CMsgCurrentEventResp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_detail(&mut self) {
        self.event_detail.clear();
    }

    pub fn has_event_detail(&self) -> bool {
        self.event_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_detail(&mut self, v: Es2CMsgCurrentEventResp) {
        self.event_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_detail(&mut self) -> &mut Es2CMsgCurrentEventResp {
        if self.event_detail.is_none() {
            self.event_detail.set_default();
        }
        self.event_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_detail(&mut self) -> Es2CMsgCurrentEventResp {
        self.event_detail.take().unwrap_or_else(|| Es2CMsgCurrentEventResp::new())
    }

    // uint32 finished_count = 6;


    pub fn get_finished_count(&self) -> u32 {
        self.finished_count
    }
    pub fn clear_finished_count(&mut self) {
        self.finished_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_finished_count(&mut self, v: u32) {
        self.finished_count = v;
    }

    // .ProtoMsg.Common.Point2 locate = 7;


    pub fn get_locate(&self) -> &super::msg_common::Point2 {
        self.locate.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locate(&mut self) {
        self.locate.clear();
    }

    pub fn has_locate(&self) -> bool {
        self.locate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locate(&mut self, v: super::msg_common::Point2) {
        self.locate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locate(&mut self) -> &mut super::msg_common::Point2 {
        if self.locate.is_none() {
            self.locate.set_default();
        }
        self.locate.as_mut().unwrap()
    }

    // Take field
    pub fn take_locate(&mut self) -> super::msg_common::Point2 {
        self.locate.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }

    // int32 event_result = 8;


    pub fn get_event_result(&self) -> i32 {
        self.event_result
    }
    pub fn clear_event_result(&mut self) {
        self.event_result = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_result(&mut self, v: i32) {
        self.event_result = v;
    }

    // uint32 max_food = 9;


    pub fn get_max_food(&self) -> u32 {
        self.max_food
    }
    pub fn clear_max_food(&mut self) {
        self.max_food = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_food(&mut self, v: u32) {
        self.max_food = v;
    }

    // uint32 consumption = 10;


    pub fn get_consumption(&self) -> u32 {
        self.consumption
    }
    pub fn clear_consumption(&mut self) {
        self.consumption = 0;
    }

    // Param is passed by value, moved
    pub fn set_consumption(&mut self, v: u32) {
        self.consumption = v;
    }
}

impl ::protobuf::Message for Es2CMsgExploreSync {
    fn is_initialized(&self) -> bool {
        for v in &self.characters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.package {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.food = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.characters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_events)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.package)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_detail)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.finished_count = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locate)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_result = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_food = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumption = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.food != 0 {
            my_size += ::protobuf::rt::value_size(1, self.food, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.characters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.new_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.package.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.event_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.finished_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.finished_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.event_result != 0 {
            my_size += ::protobuf::rt::value_size(8, self.event_result, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_food != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_food, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.consumption != 0 {
            my_size += ::protobuf::rt::value_size(10, self.consumption, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.food != 0 {
            os.write_int32(1, self.food)?;
        }
        if let Some(ref v) = self.characters.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.new_events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.package.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.event_detail.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.finished_count != 0 {
            os.write_uint32(6, self.finished_count)?;
        }
        if let Some(ref v) = self.locate.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.event_result != 0 {
            os.write_int32(8, self.event_result)?;
        }
        if self.max_food != 0 {
            os.write_uint32(9, self.max_food)?;
        }
        if self.consumption != 0 {
            os.write_uint32(10, self.consumption)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgExploreSync {
        Es2CMsgExploreSync::new()
    }

    fn default_instance() -> &'static Es2CMsgExploreSync {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgExploreSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgExploreSync::new)
    }
}

impl ::protobuf::Clear for Es2CMsgExploreSync {
    fn clear(&mut self) {
        self.food = 0;
        self.characters.clear();
        self.new_events.clear();
        self.package.clear();
        self.event_detail.clear();
        self.finished_count = 0;
        self.locate.clear();
        self.event_result = 0;
        self.max_food = 0;
        self.consumption = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgExploreSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgEventSync {
    // message fields
    pub location: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    pub event_type: EExploreEventType,
    pub event_id: u32,
    pub selections: ::std::vec::Vec<i32>,
    pub event_index: u32,
    pub uuid: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgEventSync {
    fn default() -> &'a Es2CMsgEventSync {
        <Es2CMsgEventSync as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgEventSync {
    pub fn new() -> Es2CMsgEventSync {
        ::std::default::Default::default()
    }

    // .ProtoMsg.Common.Point2 location = 1;


    pub fn get_location(&self) -> &super::msg_common::Point2 {
        self.location.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: super::msg_common::Point2) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut super::msg_common::Point2 {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> super::msg_common::Point2 {
        self.location.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }

    // .ProtoMsg.EExploreEventType event_type = 2;


    pub fn get_event_type(&self) -> EExploreEventType {
        self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = EExploreEventType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: EExploreEventType) {
        self.event_type = v;
    }

    // uint32 event_id = 3;


    pub fn get_event_id(&self) -> u32 {
        self.event_id
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = v;
    }

    // repeated int32 selections = 4;


    pub fn get_selections(&self) -> &[i32] {
        &self.selections
    }
    pub fn clear_selections(&mut self) {
        self.selections.clear();
    }

    // Param is passed by value, moved
    pub fn set_selections(&mut self, v: ::std::vec::Vec<i32>) {
        self.selections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selections(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.selections
    }

    // Take field
    pub fn take_selections(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.selections, ::std::vec::Vec::new())
    }

    // uint32 event_index = 5;


    pub fn get_event_index(&self) -> u32 {
        self.event_index
    }
    pub fn clear_event_index(&mut self) {
        self.event_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_index(&mut self, v: u32) {
        self.event_index = v;
    }

    // uint64 uuid = 6;


    pub fn get_uuid(&self) -> u64 {
        self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: u64) {
        self.uuid = v;
    }
}

impl ::protobuf::Message for Es2CMsgEventSync {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.selections)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_index = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uuid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.event_type != EExploreEventType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.event_type);
        }
        if self.event_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.event_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.selections {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.event_index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.event_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uuid != 0 {
            my_size += ::protobuf::rt::value_size(6, self.uuid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.event_type != EExploreEventType::NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.event_type))?;
        }
        if self.event_id != 0 {
            os.write_uint32(3, self.event_id)?;
        }
        for v in &self.selections {
            os.write_int32(4, *v)?;
        };
        if self.event_index != 0 {
            os.write_uint32(5, self.event_index)?;
        }
        if self.uuid != 0 {
            os.write_uint64(6, self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgEventSync {
        Es2CMsgEventSync::new()
    }

    fn default_instance() -> &'static Es2CMsgEventSync {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgEventSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgEventSync::new)
    }
}

impl ::protobuf::Clear for Es2CMsgEventSync {
    fn clear(&mut self) {
        self.location.clear();
        self.event_type = EExploreEventType::NONE;
        self.event_id = 0;
        self.selections.clear();
        self.event_index = 0;
        self.uuid = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgEventSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgExploreMoveReq {
    // message fields
    pub target: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgExploreMoveReq {
    fn default() -> &'a C2EsMsgExploreMoveReq {
        <C2EsMsgExploreMoveReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgExploreMoveReq {
    pub fn new() -> C2EsMsgExploreMoveReq {
        ::std::default::Default::default()
    }

    // .ProtoMsg.Common.Point2 target = 1;


    pub fn get_target(&self) -> &super::msg_common::Point2 {
        self.target.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: super::msg_common::Point2) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut super::msg_common::Point2 {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> super::msg_common::Point2 {
        self.target.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }
}

impl ::protobuf::Message for C2EsMsgExploreMoveReq {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgExploreMoveReq {
        C2EsMsgExploreMoveReq::new()
    }

    fn default_instance() -> &'static C2EsMsgExploreMoveReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgExploreMoveReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgExploreMoveReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgExploreMoveReq {
    fn clear(&mut self) {
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgExploreMoveReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgExploreMoveResp {
    // message fields
    pub result: i32,
    pub move_target: ::protobuf::SingularPtrField<super::msg_common::Point2>,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    pub explored_map: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgExploreMoveResp {
    fn default() -> &'a Es2CMsgExploreMoveResp {
        <Es2CMsgExploreMoveResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgExploreMoveResp {
    pub fn new() -> Es2CMsgExploreMoveResp {
        ::std::default::Default::default()
    }

    // int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = 0;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = v;
    }

    // .ProtoMsg.Common.Point2 move_target = 2;


    pub fn get_move_target(&self) -> &super::msg_common::Point2 {
        self.move_target.as_ref().unwrap_or_else(|| <super::msg_common::Point2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_move_target(&mut self) {
        self.move_target.clear();
    }

    pub fn has_move_target(&self) -> bool {
        self.move_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_target(&mut self, v: super::msg_common::Point2) {
        self.move_target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_move_target(&mut self) -> &mut super::msg_common::Point2 {
        if self.move_target.is_none() {
            self.move_target.set_default();
        }
        self.move_target.as_mut().unwrap()
    }

    // Take field
    pub fn take_move_target(&mut self) -> super::msg_common::Point2 {
        self.move_target.take().unwrap_or_else(|| super::msg_common::Point2::new())
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 3;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }

    // repeated int32 explored_map = 4;


    pub fn get_explored_map(&self) -> &[i32] {
        &self.explored_map
    }
    pub fn clear_explored_map(&mut self) {
        self.explored_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_explored_map(&mut self, v: ::std::vec::Vec<i32>) {
        self.explored_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_explored_map(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.explored_map
    }

    // Take field
    pub fn take_explored_map(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.explored_map, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Es2CMsgExploreMoveResp {
    fn is_initialized(&self) -> bool {
        for v in &self.move_target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.move_target)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.explored_map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != 0 {
            my_size += ::protobuf::rt::value_size(1, self.result, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.move_target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.explored_map {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != 0 {
            os.write_int32(1, self.result)?;
        }
        if let Some(ref v) = self.move_target.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.explored_map {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgExploreMoveResp {
        Es2CMsgExploreMoveResp::new()
    }

    fn default_instance() -> &'static Es2CMsgExploreMoveResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgExploreMoveResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgExploreMoveResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgExploreMoveResp {
    fn clear(&mut self) {
        self.result = 0;
        self.move_target.clear();
        self.explore_info.clear();
        self.explored_map.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgExploreMoveResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgExploreEventReq {
    // message fields
    pub action: ExploreEventActionType,
    pub selection: i32,
    pub event_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgExploreEventReq {
    fn default() -> &'a C2EsMsgExploreEventReq {
        <C2EsMsgExploreEventReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgExploreEventReq {
    pub fn new() -> C2EsMsgExploreEventReq {
        ::std::default::Default::default()
    }

    // .ProtoMsg.ExploreEventActionType action = 1;


    pub fn get_action(&self) -> ExploreEventActionType {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ExploreEventActionType::Cancel;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ExploreEventActionType) {
        self.action = v;
    }

    // int32 selection = 2;


    pub fn get_selection(&self) -> i32 {
        self.selection
    }
    pub fn clear_selection(&mut self) {
        self.selection = 0;
    }

    // Param is passed by value, moved
    pub fn set_selection(&mut self, v: i32) {
        self.selection = v;
    }

    // uint64 event_id = 3;


    pub fn get_event_id(&self) -> u64 {
        self.event_id
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u64) {
        self.event_id = v;
    }
}

impl ::protobuf::Message for C2EsMsgExploreEventReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.selection = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != ExploreEventActionType::Cancel {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        if self.selection != 0 {
            my_size += ::protobuf::rt::value_size(2, self.selection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.event_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != ExploreEventActionType::Cancel {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.selection != 0 {
            os.write_int32(2, self.selection)?;
        }
        if self.event_id != 0 {
            os.write_uint64(3, self.event_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgExploreEventReq {
        C2EsMsgExploreEventReq::new()
    }

    fn default_instance() -> &'static C2EsMsgExploreEventReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgExploreEventReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgExploreEventReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgExploreEventReq {
    fn clear(&mut self) {
        self.action = ExploreEventActionType::Cancel;
        self.selection = 0;
        self.event_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgExploreEventReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgExploreEventResp {
    // message fields
    pub result: i32,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    pub value0: i32,
    pub value1: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgExploreEventResp {
    fn default() -> &'a Es2CMsgExploreEventResp {
        <Es2CMsgExploreEventResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgExploreEventResp {
    pub fn new() -> Es2CMsgExploreEventResp {
        ::std::default::Default::default()
    }

    // int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = 0;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = v;
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 2;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }

    // int32 value0 = 3;


    pub fn get_value0(&self) -> i32 {
        self.value0
    }
    pub fn clear_value0(&mut self) {
        self.value0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_value0(&mut self, v: i32) {
        self.value0 = v;
    }

    // int32 value1 = 4;


    pub fn get_value1(&self) -> i32 {
        self.value1
    }
    pub fn clear_value1(&mut self) {
        self.value1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_value1(&mut self, v: i32) {
        self.value1 = v;
    }
}

impl ::protobuf::Message for Es2CMsgExploreEventResp {
    fn is_initialized(&self) -> bool {
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value0 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value1 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != 0 {
            my_size += ::protobuf::rt::value_size(1, self.result, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value0 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.value0, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value1 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.value1, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != 0 {
            os.write_int32(1, self.result)?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value0 != 0 {
            os.write_int32(3, self.value0)?;
        }
        if self.value1 != 0 {
            os.write_int32(4, self.value1)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgExploreEventResp {
        Es2CMsgExploreEventResp::new()
    }

    fn default_instance() -> &'static Es2CMsgExploreEventResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgExploreEventResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgExploreEventResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgExploreEventResp {
    fn clear(&mut self) {
        self.result = 0;
        self.explore_info.clear();
        self.value0 = 0;
        self.value1 = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgExploreEventResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgExploreResultReq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgExploreResultReq {
    fn default() -> &'a C2EsMsgExploreResultReq {
        <C2EsMsgExploreResultReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgExploreResultReq {
    pub fn new() -> C2EsMsgExploreResultReq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for C2EsMsgExploreResultReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgExploreResultReq {
        C2EsMsgExploreResultReq::new()
    }

    fn default_instance() -> &'static C2EsMsgExploreResultReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgExploreResultReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgExploreResultReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgExploreResultReq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgExploreResultReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgExploreResultResp {
    // message fields
    pub result: ExploreResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgExploreResultResp {
    fn default() -> &'a Es2CMsgExploreResultResp {
        <Es2CMsgExploreResultResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgExploreResultResp {
    pub fn new() -> Es2CMsgExploreResultResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.ExploreResult result = 1;


    pub fn get_result(&self) -> ExploreResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = ExploreResult::FINISHED;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ExploreResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgExploreResultResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != ExploreResult::FINISHED {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != ExploreResult::FINISHED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgExploreResultResp {
        Es2CMsgExploreResultResp::new()
    }

    fn default_instance() -> &'static Es2CMsgExploreResultResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgExploreResultResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgExploreResultResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgExploreResultResp {
    fn clear(&mut self) {
        self.result = ExploreResult::FINISHED;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgExploreResultResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BattleCharacterInfo {
    // message fields
    pub id: u32,
    pub health: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BattleCharacterInfo {
    fn default() -> &'a BattleCharacterInfo {
        <BattleCharacterInfo as ::protobuf::Message>::default_instance()
    }
}

impl BattleCharacterInfo {
    pub fn new() -> BattleCharacterInfo {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // int32 health = 2;


    pub fn get_health(&self) -> i32 {
        self.health
    }
    pub fn clear_health(&mut self) {
        self.health = 0;
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = v;
    }
}

impl ::protobuf::Message for BattleCharacterInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.health = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.health != 0 {
            my_size += ::protobuf::rt::value_size(2, self.health, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.health != 0 {
            os.write_int32(2, self.health)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BattleCharacterInfo {
        BattleCharacterInfo::new()
    }

    fn default_instance() -> &'static BattleCharacterInfo {
        static instance: ::protobuf::rt::LazyV2<BattleCharacterInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BattleCharacterInfo::new)
    }
}

impl ::protobuf::Clear for BattleCharacterInfo {
    fn clear(&mut self) {
        self.id = 0;
        self.health = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BattleCharacterInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgBattleResultReq {
    // message fields
    pub success: bool,
    pub characters: ::protobuf::RepeatedField<BattleCharacterInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgBattleResultReq {
    fn default() -> &'a C2EsMsgBattleResultReq {
        <C2EsMsgBattleResultReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgBattleResultReq {
    pub fn new() -> C2EsMsgBattleResultReq {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // repeated .ProtoMsg.BattleCharacterInfo characters = 2;


    pub fn get_characters(&self) -> &[BattleCharacterInfo] {
        &self.characters
    }
    pub fn clear_characters(&mut self) {
        self.characters.clear();
    }

    // Param is passed by value, moved
    pub fn set_characters(&mut self, v: ::protobuf::RepeatedField<BattleCharacterInfo>) {
        self.characters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_characters(&mut self) -> &mut ::protobuf::RepeatedField<BattleCharacterInfo> {
        &mut self.characters
    }

    // Take field
    pub fn take_characters(&mut self) -> ::protobuf::RepeatedField<BattleCharacterInfo> {
        ::std::mem::replace(&mut self.characters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for C2EsMsgBattleResultReq {
    fn is_initialized(&self) -> bool {
        for v in &self.characters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.characters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.characters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.characters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgBattleResultReq {
        C2EsMsgBattleResultReq::new()
    }

    fn default_instance() -> &'static C2EsMsgBattleResultReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgBattleResultReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgBattleResultReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgBattleResultReq {
    fn clear(&mut self) {
        self.success = false;
        self.characters.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgBattleResultReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgBattleResultResp {
    // message fields
    pub result: i32,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgBattleResultResp {
    fn default() -> &'a Es2CMsgBattleResultResp {
        <Es2CMsgBattleResultResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgBattleResultResp {
    pub fn new() -> Es2CMsgBattleResultResp {
        ::std::default::Default::default()
    }

    // int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = 0;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = v;
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 2;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }
}

impl ::protobuf::Message for Es2CMsgBattleResultResp {
    fn is_initialized(&self) -> bool {
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != 0 {
            my_size += ::protobuf::rt::value_size(1, self.result, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != 0 {
            os.write_int32(1, self.result)?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgBattleResultResp {
        Es2CMsgBattleResultResp::new()
    }

    fn default_instance() -> &'static Es2CMsgBattleResultResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgBattleResultResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgBattleResultResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgBattleResultResp {
    fn clear(&mut self) {
        self.result = 0;
        self.explore_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgBattleResultResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgQuitExploreReq {
    // message fields
    pub reason: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgQuitExploreReq {
    fn default() -> &'a C2EsMsgQuitExploreReq {
        <C2EsMsgQuitExploreReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgQuitExploreReq {
    pub fn new() -> C2EsMsgQuitExploreReq {
        ::std::default::Default::default()
    }

    // int32 reason = 1;


    pub fn get_reason(&self) -> i32 {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = 0;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = v;
    }
}

impl ::protobuf::Message for C2EsMsgQuitExploreReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reason != 0 {
            my_size += ::protobuf::rt::value_size(1, self.reason, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reason != 0 {
            os.write_int32(1, self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgQuitExploreReq {
        C2EsMsgQuitExploreReq::new()
    }

    fn default_instance() -> &'static C2EsMsgQuitExploreReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgQuitExploreReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgQuitExploreReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgQuitExploreReq {
    fn clear(&mut self) {
        self.reason = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgQuitExploreReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgQuitExploreResp {
    // message fields
    pub result: i32,
    pub package: ::protobuf::RepeatedField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgQuitExploreResp {
    fn default() -> &'a Es2CMsgQuitExploreResp {
        <Es2CMsgQuitExploreResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgQuitExploreResp {
    pub fn new() -> Es2CMsgQuitExploreResp {
        ::std::default::Default::default()
    }

    // int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = 0;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = v;
    }

    // repeated .ProtoMsg.ExploreItemInfo package = 2;


    pub fn get_package(&self) -> &[ExploreItemInfo] {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::protobuf::RepeatedField<ExploreItemInfo>) {
        self.package = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package(&mut self) -> &mut ::protobuf::RepeatedField<ExploreItemInfo> {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::protobuf::RepeatedField<ExploreItemInfo> {
        ::std::mem::replace(&mut self.package, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2CMsgQuitExploreResp {
    fn is_initialized(&self) -> bool {
        for v in &self.package {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != 0 {
            my_size += ::protobuf::rt::value_size(1, self.result, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.package {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != 0 {
            os.write_int32(1, self.result)?;
        }
        for v in &self.package {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgQuitExploreResp {
        Es2CMsgQuitExploreResp::new()
    }

    fn default_instance() -> &'static Es2CMsgQuitExploreResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgQuitExploreResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgQuitExploreResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgQuitExploreResp {
    fn clear(&mut self) {
        self.result = 0;
        self.package.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgQuitExploreResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgCurrentEventReq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgCurrentEventReq {
    fn default() -> &'a C2EsMsgCurrentEventReq {
        <C2EsMsgCurrentEventReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgCurrentEventReq {
    pub fn new() -> C2EsMsgCurrentEventReq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for C2EsMsgCurrentEventReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgCurrentEventReq {
        C2EsMsgCurrentEventReq::new()
    }

    fn default_instance() -> &'static C2EsMsgCurrentEventReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgCurrentEventReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgCurrentEventReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgCurrentEventReq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgCurrentEventReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgCurrentEventResp {
    // message fields
    pub trigger_event: ::protobuf::SingularPtrField<Es2CMsgEventSync>,
    pub other_events: ::protobuf::RepeatedField<Es2CMsgEventSync>,
    pub event_state: i32,
    pub npc_infos: ::protobuf::RepeatedField<Es2CMsgNpcInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgCurrentEventResp {
    fn default() -> &'a Es2CMsgCurrentEventResp {
        <Es2CMsgCurrentEventResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgCurrentEventResp {
    pub fn new() -> Es2CMsgCurrentEventResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.Es2CMsgEventSync trigger_event = 1;


    pub fn get_trigger_event(&self) -> &Es2CMsgEventSync {
        self.trigger_event.as_ref().unwrap_or_else(|| <Es2CMsgEventSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trigger_event(&mut self) {
        self.trigger_event.clear();
    }

    pub fn has_trigger_event(&self) -> bool {
        self.trigger_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger_event(&mut self, v: Es2CMsgEventSync) {
        self.trigger_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_event(&mut self) -> &mut Es2CMsgEventSync {
        if self.trigger_event.is_none() {
            self.trigger_event.set_default();
        }
        self.trigger_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger_event(&mut self) -> Es2CMsgEventSync {
        self.trigger_event.take().unwrap_or_else(|| Es2CMsgEventSync::new())
    }

    // repeated .ProtoMsg.Es2CMsgEventSync other_events = 2;


    pub fn get_other_events(&self) -> &[Es2CMsgEventSync] {
        &self.other_events
    }
    pub fn clear_other_events(&mut self) {
        self.other_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_events(&mut self, v: ::protobuf::RepeatedField<Es2CMsgEventSync>) {
        self.other_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_events(&mut self) -> &mut ::protobuf::RepeatedField<Es2CMsgEventSync> {
        &mut self.other_events
    }

    // Take field
    pub fn take_other_events(&mut self) -> ::protobuf::RepeatedField<Es2CMsgEventSync> {
        ::std::mem::replace(&mut self.other_events, ::protobuf::RepeatedField::new())
    }

    // int32 event_state = 3;


    pub fn get_event_state(&self) -> i32 {
        self.event_state
    }
    pub fn clear_event_state(&mut self) {
        self.event_state = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_state(&mut self, v: i32) {
        self.event_state = v;
    }

    // repeated .ProtoMsg.Es2CMsgNpcInfo npc_infos = 4;


    pub fn get_npc_infos(&self) -> &[Es2CMsgNpcInfo] {
        &self.npc_infos
    }
    pub fn clear_npc_infos(&mut self) {
        self.npc_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_npc_infos(&mut self, v: ::protobuf::RepeatedField<Es2CMsgNpcInfo>) {
        self.npc_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_npc_infos(&mut self) -> &mut ::protobuf::RepeatedField<Es2CMsgNpcInfo> {
        &mut self.npc_infos
    }

    // Take field
    pub fn take_npc_infos(&mut self) -> ::protobuf::RepeatedField<Es2CMsgNpcInfo> {
        ::std::mem::replace(&mut self.npc_infos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2CMsgCurrentEventResp {
    fn is_initialized(&self) -> bool {
        for v in &self.trigger_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.other_events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.npc_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trigger_event)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.other_events)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_state = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.npc_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trigger_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.other_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.event_state != 0 {
            my_size += ::protobuf::rt::value_size(3, self.event_state, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.npc_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trigger_event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.other_events {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.event_state != 0 {
            os.write_int32(3, self.event_state)?;
        }
        for v in &self.npc_infos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgCurrentEventResp {
        Es2CMsgCurrentEventResp::new()
    }

    fn default_instance() -> &'static Es2CMsgCurrentEventResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgCurrentEventResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgCurrentEventResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgCurrentEventResp {
    fn clear(&mut self) {
        self.trigger_event.clear();
        self.other_events.clear();
        self.event_state = 0;
        self.npc_infos.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgCurrentEventResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgDropItemReq {
    // message fields
    pub item: ::protobuf::SingularPtrField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgDropItemReq {
    fn default() -> &'a C2EsMsgDropItemReq {
        <C2EsMsgDropItemReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgDropItemReq {
    pub fn new() -> C2EsMsgDropItemReq {
        ::std::default::Default::default()
    }

    // .ProtoMsg.ExploreItemInfo item = 1;


    pub fn get_item(&self) -> &ExploreItemInfo {
        self.item.as_ref().unwrap_or_else(|| <ExploreItemInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ExploreItemInfo) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ExploreItemInfo {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ExploreItemInfo {
        self.item.take().unwrap_or_else(|| ExploreItemInfo::new())
    }
}

impl ::protobuf::Message for C2EsMsgDropItemReq {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgDropItemReq {
        C2EsMsgDropItemReq::new()
    }

    fn default_instance() -> &'static C2EsMsgDropItemReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgDropItemReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgDropItemReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgDropItemReq {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgDropItemReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgDropItemResp {
    // message fields
    pub result: CEsResult,
    pub package: ::protobuf::RepeatedField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgDropItemResp {
    fn default() -> &'a Es2CMsgDropItemResp {
        <Es2CMsgDropItemResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgDropItemResp {
    pub fn new() -> Es2CMsgDropItemResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }

    // repeated .ProtoMsg.ExploreItemInfo package = 2;


    pub fn get_package(&self) -> &[ExploreItemInfo] {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::protobuf::RepeatedField<ExploreItemInfo>) {
        self.package = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package(&mut self) -> &mut ::protobuf::RepeatedField<ExploreItemInfo> {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::protobuf::RepeatedField<ExploreItemInfo> {
        ::std::mem::replace(&mut self.package, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2CMsgDropItemResp {
    fn is_initialized(&self) -> bool {
        for v in &self.package {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        for value in &self.package {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        for v in &self.package {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgDropItemResp {
        Es2CMsgDropItemResp::new()
    }

    fn default_instance() -> &'static Es2CMsgDropItemResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgDropItemResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgDropItemResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgDropItemResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.package.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgDropItemResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgUseItemReq {
    // message fields
    pub item_id: u32,
    pub character_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgUseItemReq {
    fn default() -> &'a C2EsMsgUseItemReq {
        <C2EsMsgUseItemReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgUseItemReq {
    pub fn new() -> C2EsMsgUseItemReq {
        ::std::default::Default::default()
    }

    // uint32 item_id = 1;


    pub fn get_item_id(&self) -> u32 {
        self.item_id
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = v;
    }

    // uint32 character_id = 2;


    pub fn get_character_id(&self) -> u32 {
        self.character_id
    }
    pub fn clear_character_id(&mut self) {
        self.character_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_character_id(&mut self, v: u32) {
        self.character_id = v;
    }
}

impl ::protobuf::Message for C2EsMsgUseItemReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.character_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.item_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.item_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.character_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.character_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.item_id != 0 {
            os.write_uint32(1, self.item_id)?;
        }
        if self.character_id != 0 {
            os.write_uint32(2, self.character_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgUseItemReq {
        C2EsMsgUseItemReq::new()
    }

    fn default_instance() -> &'static C2EsMsgUseItemReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgUseItemReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgUseItemReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgUseItemReq {
    fn clear(&mut self) {
        self.item_id = 0;
        self.character_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgUseItemReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UseChange {
    // message fields
    pub field_type: i32,
    pub id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UseChange {
    fn default() -> &'a UseChange {
        <UseChange as ::protobuf::Message>::default_instance()
    }
}

impl UseChange {
    pub fn new() -> UseChange {
        ::std::default::Default::default()
    }

    // int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = v;
    }

    // int32 id = 2;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }
}

impl ::protobuf::Message for UseChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_int32(1, self.field_type)?;
        }
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UseChange {
        UseChange::new()
    }

    fn default_instance() -> &'static UseChange {
        static instance: ::protobuf::rt::LazyV2<UseChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UseChange::new)
    }
}

impl ::protobuf::Clear for UseChange {
    fn clear(&mut self) {
        self.field_type = 0;
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UseChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgUseItemResp {
    // message fields
    pub result: CEsResult,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    pub use_change: ::protobuf::RepeatedField<UseChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgUseItemResp {
    fn default() -> &'a Es2CMsgUseItemResp {
        <Es2CMsgUseItemResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgUseItemResp {
    pub fn new() -> Es2CMsgUseItemResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 2;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }

    // repeated .ProtoMsg.UseChange use_change = 3;


    pub fn get_use_change(&self) -> &[UseChange] {
        &self.use_change
    }
    pub fn clear_use_change(&mut self) {
        self.use_change.clear();
    }

    // Param is passed by value, moved
    pub fn set_use_change(&mut self, v: ::protobuf::RepeatedField<UseChange>) {
        self.use_change = v;
    }

    // Mutable pointer to the field.
    pub fn mut_use_change(&mut self) -> &mut ::protobuf::RepeatedField<UseChange> {
        &mut self.use_change
    }

    // Take field
    pub fn take_use_change(&mut self) -> ::protobuf::RepeatedField<UseChange> {
        ::std::mem::replace(&mut self.use_change, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2CMsgUseItemResp {
    fn is_initialized(&self) -> bool {
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.use_change {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.use_change)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.use_change {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.use_change {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgUseItemResp {
        Es2CMsgUseItemResp::new()
    }

    fn default_instance() -> &'static Es2CMsgUseItemResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgUseItemResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgUseItemResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgUseItemResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.explore_info.clear();
        self.use_change.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgUseItemResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgFoodNumReq {
    // message fields
    pub num: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgFoodNumReq {
    fn default() -> &'a C2EsMsgFoodNumReq {
        <C2EsMsgFoodNumReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgFoodNumReq {
    pub fn new() -> C2EsMsgFoodNumReq {
        ::std::default::Default::default()
    }

    // uint32 num = 1;


    pub fn get_num(&self) -> u32 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: u32) {
        self.num = v;
    }
}

impl ::protobuf::Message for C2EsMsgFoodNumReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num != 0 {
            os.write_uint32(1, self.num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgFoodNumReq {
        C2EsMsgFoodNumReq::new()
    }

    fn default_instance() -> &'static C2EsMsgFoodNumReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgFoodNumReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgFoodNumReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgFoodNumReq {
    fn clear(&mut self) {
        self.num = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgFoodNumReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgFoodNumResp {
    // message fields
    pub result: CEsResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgFoodNumResp {
    fn default() -> &'a Es2CMsgFoodNumResp {
        <Es2CMsgFoodNumResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgFoodNumResp {
    pub fn new() -> Es2CMsgFoodNumResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgFoodNumResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgFoodNumResp {
        Es2CMsgFoodNumResp::new()
    }

    fn default_instance() -> &'static Es2CMsgFoodNumResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgFoodNumResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgFoodNumResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgFoodNumResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgFoodNumResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgRemoveBackpackReq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgRemoveBackpackReq {
    fn default() -> &'a C2EsMsgRemoveBackpackReq {
        <C2EsMsgRemoveBackpackReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgRemoveBackpackReq {
    pub fn new() -> C2EsMsgRemoveBackpackReq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for C2EsMsgRemoveBackpackReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgRemoveBackpackReq {
        C2EsMsgRemoveBackpackReq::new()
    }

    fn default_instance() -> &'static C2EsMsgRemoveBackpackReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgRemoveBackpackReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgRemoveBackpackReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgRemoveBackpackReq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgRemoveBackpackReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgRemoveBackpackResp {
    // message fields
    pub result: CEsResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgRemoveBackpackResp {
    fn default() -> &'a Es2CMsgRemoveBackpackResp {
        <Es2CMsgRemoveBackpackResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgRemoveBackpackResp {
    pub fn new() -> Es2CMsgRemoveBackpackResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgRemoveBackpackResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgRemoveBackpackResp {
        Es2CMsgRemoveBackpackResp::new()
    }

    fn default_instance() -> &'static Es2CMsgRemoveBackpackResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgRemoveBackpackResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgRemoveBackpackResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgRemoveBackpackResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgRemoveBackpackResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgGiveItemsReq {
    // message fields
    pub items: ::protobuf::RepeatedField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgGiveItemsReq {
    fn default() -> &'a C2EsMsgGiveItemsReq {
        <C2EsMsgGiveItemsReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgGiveItemsReq {
    pub fn new() -> C2EsMsgGiveItemsReq {
        ::std::default::Default::default()
    }

    // repeated .ProtoMsg.ExploreItemInfo items = 1;


    pub fn get_items(&self) -> &[ExploreItemInfo] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ExploreItemInfo>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ExploreItemInfo> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ExploreItemInfo> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for C2EsMsgGiveItemsReq {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgGiveItemsReq {
        C2EsMsgGiveItemsReq::new()
    }

    fn default_instance() -> &'static C2EsMsgGiveItemsReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgGiveItemsReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgGiveItemsReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgGiveItemsReq {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgGiveItemsReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgGiveItemsResp {
    // message fields
    pub result: CEsResult,
    pub package: ::protobuf::RepeatedField<ExploreItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgGiveItemsResp {
    fn default() -> &'a Es2CMsgGiveItemsResp {
        <Es2CMsgGiveItemsResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgGiveItemsResp {
    pub fn new() -> Es2CMsgGiveItemsResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }

    // repeated .ProtoMsg.ExploreItemInfo package = 2;


    pub fn get_package(&self) -> &[ExploreItemInfo] {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::protobuf::RepeatedField<ExploreItemInfo>) {
        self.package = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package(&mut self) -> &mut ::protobuf::RepeatedField<ExploreItemInfo> {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::protobuf::RepeatedField<ExploreItemInfo> {
        ::std::mem::replace(&mut self.package, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Es2CMsgGiveItemsResp {
    fn is_initialized(&self) -> bool {
        for v in &self.package {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        for value in &self.package {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        for v in &self.package {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgGiveItemsResp {
        Es2CMsgGiveItemsResp::new()
    }

    fn default_instance() -> &'static Es2CMsgGiveItemsResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgGiveItemsResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgGiveItemsResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgGiveItemsResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.package.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgGiveItemsResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgTeamBuffReq {
    // message fields
    pub buffs: ::protobuf::RepeatedField<ExploreBuff>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgTeamBuffReq {
    fn default() -> &'a C2EsMsgTeamBuffReq {
        <C2EsMsgTeamBuffReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgTeamBuffReq {
    pub fn new() -> C2EsMsgTeamBuffReq {
        ::std::default::Default::default()
    }

    // repeated .ProtoMsg.ExploreBuff buffs = 1;


    pub fn get_buffs(&self) -> &[ExploreBuff] {
        &self.buffs
    }
    pub fn clear_buffs(&mut self) {
        self.buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffs(&mut self, v: ::protobuf::RepeatedField<ExploreBuff>) {
        self.buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffs(&mut self) -> &mut ::protobuf::RepeatedField<ExploreBuff> {
        &mut self.buffs
    }

    // Take field
    pub fn take_buffs(&mut self) -> ::protobuf::RepeatedField<ExploreBuff> {
        ::std::mem::replace(&mut self.buffs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for C2EsMsgTeamBuffReq {
    fn is_initialized(&self) -> bool {
        for v in &self.buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buffs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buffs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buffs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgTeamBuffReq {
        C2EsMsgTeamBuffReq::new()
    }

    fn default_instance() -> &'static C2EsMsgTeamBuffReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgTeamBuffReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgTeamBuffReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgTeamBuffReq {
    fn clear(&mut self) {
        self.buffs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgTeamBuffReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgTeamBuffResp {
    // message fields
    pub result: CEsResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgTeamBuffResp {
    fn default() -> &'a Es2CMsgTeamBuffResp {
        <Es2CMsgTeamBuffResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgTeamBuffResp {
    pub fn new() -> Es2CMsgTeamBuffResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgTeamBuffResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgTeamBuffResp {
        Es2CMsgTeamBuffResp::new()
    }

    fn default_instance() -> &'static Es2CMsgTeamBuffResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgTeamBuffResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgTeamBuffResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgTeamBuffResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgTeamBuffResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgWinReq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgWinReq {
    fn default() -> &'a C2EsMsgWinReq {
        <C2EsMsgWinReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgWinReq {
    pub fn new() -> C2EsMsgWinReq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for C2EsMsgWinReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgWinReq {
        C2EsMsgWinReq::new()
    }

    fn default_instance() -> &'static C2EsMsgWinReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgWinReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgWinReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgWinReq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgWinReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgWinResp {
    // message fields
    pub result: CEsResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgWinResp {
    fn default() -> &'a Es2CMsgWinResp {
        <Es2CMsgWinResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgWinResp {
    pub fn new() -> Es2CMsgWinResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgWinResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgWinResp {
        Es2CMsgWinResp::new()
    }

    fn default_instance() -> &'static Es2CMsgWinResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgWinResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgWinResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgWinResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgWinResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct C2EsMsgDarkThunderReq {
    // message fields
    pub switch: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2EsMsgDarkThunderReq {
    fn default() -> &'a C2EsMsgDarkThunderReq {
        <C2EsMsgDarkThunderReq as ::protobuf::Message>::default_instance()
    }
}

impl C2EsMsgDarkThunderReq {
    pub fn new() -> C2EsMsgDarkThunderReq {
        ::std::default::Default::default()
    }

    // uint32 switch = 1;


    pub fn get_switch(&self) -> u32 {
        self.switch
    }
    pub fn clear_switch(&mut self) {
        self.switch = 0;
    }

    // Param is passed by value, moved
    pub fn set_switch(&mut self, v: u32) {
        self.switch = v;
    }
}

impl ::protobuf::Message for C2EsMsgDarkThunderReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.switch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.switch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.switch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.switch != 0 {
            os.write_uint32(1, self.switch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2EsMsgDarkThunderReq {
        C2EsMsgDarkThunderReq::new()
    }

    fn default_instance() -> &'static C2EsMsgDarkThunderReq {
        static instance: ::protobuf::rt::LazyV2<C2EsMsgDarkThunderReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2EsMsgDarkThunderReq::new)
    }
}

impl ::protobuf::Clear for C2EsMsgDarkThunderReq {
    fn clear(&mut self) {
        self.switch = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for C2EsMsgDarkThunderReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgDarkThunderResp {
    // message fields
    pub result: CEsResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgDarkThunderResp {
    fn default() -> &'a Es2CMsgDarkThunderResp {
        <Es2CMsgDarkThunderResp as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgDarkThunderResp {
    pub fn new() -> Es2CMsgDarkThunderResp {
        ::std::default::Default::default()
    }

    // .ProtoMsg.CEsResult result = 1;


    pub fn get_result(&self) -> CEsResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CEsResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for Es2CMsgDarkThunderResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CEsResult::RR_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CEsResult::RR_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgDarkThunderResp {
        Es2CMsgDarkThunderResp::new()
    }

    fn default_instance() -> &'static Es2CMsgDarkThunderResp {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgDarkThunderResp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgDarkThunderResp::new)
    }
}

impl ::protobuf::Clear for Es2CMsgDarkThunderResp {
    fn clear(&mut self) {
        self.result = CEsResult::RR_SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgDarkThunderResp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgMapStateSync {
    // message fields
    pub closed_map: ::std::vec::Vec<i32>,
    pub opend_map: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgMapStateSync {
    fn default() -> &'a Es2CMsgMapStateSync {
        <Es2CMsgMapStateSync as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgMapStateSync {
    pub fn new() -> Es2CMsgMapStateSync {
        ::std::default::Default::default()
    }

    // repeated int32 closed_map = 1;


    pub fn get_closed_map(&self) -> &[i32] {
        &self.closed_map
    }
    pub fn clear_closed_map(&mut self) {
        self.closed_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_closed_map(&mut self, v: ::std::vec::Vec<i32>) {
        self.closed_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_closed_map(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.closed_map
    }

    // Take field
    pub fn take_closed_map(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.closed_map, ::std::vec::Vec::new())
    }

    // repeated int32 opend_map = 2;


    pub fn get_opend_map(&self) -> &[i32] {
        &self.opend_map
    }
    pub fn clear_opend_map(&mut self) {
        self.opend_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_opend_map(&mut self, v: ::std::vec::Vec<i32>) {
        self.opend_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opend_map(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.opend_map
    }

    // Take field
    pub fn take_opend_map(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.opend_map, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Es2CMsgMapStateSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.closed_map)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.opend_map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.closed_map {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.opend_map {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.closed_map {
            os.write_int32(1, *v)?;
        };
        for v in &self.opend_map {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgMapStateSync {
        Es2CMsgMapStateSync::new()
    }

    fn default_instance() -> &'static Es2CMsgMapStateSync {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgMapStateSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgMapStateSync::new)
    }
}

impl ::protobuf::Clear for Es2CMsgMapStateSync {
    fn clear(&mut self) {
        self.closed_map.clear();
        self.opend_map.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgMapStateSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgPortalSync {
    // message fields
    pub map_id: u32,
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    pub explored_map: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgPortalSync {
    fn default() -> &'a Es2CMsgPortalSync {
        <Es2CMsgPortalSync as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgPortalSync {
    pub fn new() -> Es2CMsgPortalSync {
        ::std::default::Default::default()
    }

    // uint32 map_id = 1;


    pub fn get_map_id(&self) -> u32 {
        self.map_id
    }
    pub fn clear_map_id(&mut self) {
        self.map_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_map_id(&mut self, v: u32) {
        self.map_id = v;
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 2;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }

    // repeated int32 explored_map = 3;


    pub fn get_explored_map(&self) -> &[i32] {
        &self.explored_map
    }
    pub fn clear_explored_map(&mut self) {
        self.explored_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_explored_map(&mut self, v: ::std::vec::Vec<i32>) {
        self.explored_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_explored_map(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.explored_map
    }

    // Take field
    pub fn take_explored_map(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.explored_map, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Es2CMsgPortalSync {
    fn is_initialized(&self) -> bool {
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.explored_map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.map_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.map_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.explored_map {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.map_id != 0 {
            os.write_uint32(1, self.map_id)?;
        }
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.explored_map {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgPortalSync {
        Es2CMsgPortalSync::new()
    }

    fn default_instance() -> &'static Es2CMsgPortalSync {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgPortalSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgPortalSync::new)
    }
}

impl ::protobuf::Clear for Es2CMsgPortalSync {
    fn clear(&mut self) {
        self.map_id = 0;
        self.explore_info.clear();
        self.explored_map.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgPortalSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgLoseEfficacy {
    // message fields
    pub explore_info: ::protobuf::SingularPtrField<Es2CMsgExploreSync>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgLoseEfficacy {
    fn default() -> &'a Es2CMsgLoseEfficacy {
        <Es2CMsgLoseEfficacy as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgLoseEfficacy {
    pub fn new() -> Es2CMsgLoseEfficacy {
        ::std::default::Default::default()
    }

    // .ProtoMsg.Es2CMsgExploreSync explore_info = 1;


    pub fn get_explore_info(&self) -> &Es2CMsgExploreSync {
        self.explore_info.as_ref().unwrap_or_else(|| <Es2CMsgExploreSync as ::protobuf::Message>::default_instance())
    }
    pub fn clear_explore_info(&mut self) {
        self.explore_info.clear();
    }

    pub fn has_explore_info(&self) -> bool {
        self.explore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explore_info(&mut self, v: Es2CMsgExploreSync) {
        self.explore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_explore_info(&mut self) -> &mut Es2CMsgExploreSync {
        if self.explore_info.is_none() {
            self.explore_info.set_default();
        }
        self.explore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_explore_info(&mut self) -> Es2CMsgExploreSync {
        self.explore_info.take().unwrap_or_else(|| Es2CMsgExploreSync::new())
    }
}

impl ::protobuf::Message for Es2CMsgLoseEfficacy {
    fn is_initialized(&self) -> bool {
        for v in &self.explore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.explore_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.explore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.explore_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgLoseEfficacy {
        Es2CMsgLoseEfficacy::new()
    }

    fn default_instance() -> &'static Es2CMsgLoseEfficacy {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgLoseEfficacy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgLoseEfficacy::new)
    }
}

impl ::protobuf::Clear for Es2CMsgLoseEfficacy {
    fn clear(&mut self) {
        self.explore_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgLoseEfficacy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Es2CMsgTaskSync {
    // message fields
    pub finished_targets: ::std::vec::Vec<u32>,
    pub failed_targets: ::std::vec::Vec<u32>,
    pub new_targets: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Es2CMsgTaskSync {
    fn default() -> &'a Es2CMsgTaskSync {
        <Es2CMsgTaskSync as ::protobuf::Message>::default_instance()
    }
}

impl Es2CMsgTaskSync {
    pub fn new() -> Es2CMsgTaskSync {
        ::std::default::Default::default()
    }

    // repeated uint32 finished_targets = 1;


    pub fn get_finished_targets(&self) -> &[u32] {
        &self.finished_targets
    }
    pub fn clear_finished_targets(&mut self) {
        self.finished_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_finished_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.finished_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finished_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.finished_targets
    }

    // Take field
    pub fn take_finished_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.finished_targets, ::std::vec::Vec::new())
    }

    // repeated uint32 failed_targets = 2;


    pub fn get_failed_targets(&self) -> &[u32] {
        &self.failed_targets
    }
    pub fn clear_failed_targets(&mut self) {
        self.failed_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.failed_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failed_targets
    }

    // Take field
    pub fn take_failed_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.failed_targets, ::std::vec::Vec::new())
    }

    // repeated uint32 new_targets = 3;


    pub fn get_new_targets(&self) -> &[u32] {
        &self.new_targets
    }
    pub fn clear_new_targets(&mut self) {
        self.new_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.new_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.new_targets
    }

    // Take field
    pub fn take_new_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.new_targets, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Es2CMsgTaskSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.finished_targets)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.failed_targets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.new_targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.finished_targets {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.failed_targets {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.new_targets {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.finished_targets {
            os.write_uint32(1, *v)?;
        };
        for v in &self.failed_targets {
            os.write_uint32(2, *v)?;
        };
        for v in &self.new_targets {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Es2CMsgTaskSync {
        Es2CMsgTaskSync::new()
    }

    fn default_instance() -> &'static Es2CMsgTaskSync {
        static instance: ::protobuf::rt::LazyV2<Es2CMsgTaskSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Es2CMsgTaskSync::new)
    }
}

impl ::protobuf::Clear for Es2CMsgTaskSync {
    fn clear(&mut self) {
        self.finished_targets.clear();
        self.failed_targets.clear();
        self.new_targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Es2CMsgTaskSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExploreMsgId {
    ERROR_MSG_ID = 0,
    MsgIdCreateExploreReq = 4001,
    MsgIdCreateExploreResp = 4002,
    MsgIdKickOff = 4003,
    MsgIdExploreMoveReq = 4004,
    MsgIdExploreMoveResp = 4005,
    MsgIdExploreEventReq = 4006,
    MsgIdExploreEventResp = 4007,
    MsgIdExploreSyncResp = 4008,
    MsgIdExploreBattleResultReq = 4009,
    MsgIdQuitExploreReq = 4010,
    MsgIdQuitExploreResp = 4011,
    MsgIdExploreBattleResultResp = 4012,
    MsgIdCurrentEventReq = 4013,
    MsgIdCurrentEventResp = 4014,
    MsgIdMsgDropItemReq = 4015,
    MsgIdMsgDropItemResp = 4016,
    MsgIdUseItemReq = 4017,
    MsgIdUseItemResp = 4018,
    MsgIdFoodNumReq = 4019,
    MsgIdFoodNumResp = 4020,
    MsgIdRemoveBackpackReq = 4021,
    MsgIdRemoveBackpackResp = 4022,
    MsgIdGiveItemsReq = 4023,
    MsgIdGiveItemsResp = 4024,
    MsgIdTeamBuffReq = 4025,
    MsgIdTeamBuffResp = 4026,
    MsgIdWinReq = 4027,
    MsgIdWinResp = 4028,
    MsgIdDarkThunderReq = 4029,
    MsgIdDarkThunderResp = 4030,
    MsgIdMapStateSync = 4131,
    MsgIdPortal = 4132,
    MsgIdTaskSync = 4200,
}

impl ::protobuf::ProtobufEnum for ExploreMsgId {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExploreMsgId> {
        match value {
            0 => ::std::option::Option::Some(ExploreMsgId::ERROR_MSG_ID),
            4001 => ::std::option::Option::Some(ExploreMsgId::MsgIdCreateExploreReq),
            4002 => ::std::option::Option::Some(ExploreMsgId::MsgIdCreateExploreResp),
            4003 => ::std::option::Option::Some(ExploreMsgId::MsgIdKickOff),
            4004 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreMoveReq),
            4005 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreMoveResp),
            4006 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreEventReq),
            4007 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreEventResp),
            4008 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreSyncResp),
            4009 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreBattleResultReq),
            4010 => ::std::option::Option::Some(ExploreMsgId::MsgIdQuitExploreReq),
            4011 => ::std::option::Option::Some(ExploreMsgId::MsgIdQuitExploreResp),
            4012 => ::std::option::Option::Some(ExploreMsgId::MsgIdExploreBattleResultResp),
            4013 => ::std::option::Option::Some(ExploreMsgId::MsgIdCurrentEventReq),
            4014 => ::std::option::Option::Some(ExploreMsgId::MsgIdCurrentEventResp),
            4015 => ::std::option::Option::Some(ExploreMsgId::MsgIdMsgDropItemReq),
            4016 => ::std::option::Option::Some(ExploreMsgId::MsgIdMsgDropItemResp),
            4017 => ::std::option::Option::Some(ExploreMsgId::MsgIdUseItemReq),
            4018 => ::std::option::Option::Some(ExploreMsgId::MsgIdUseItemResp),
            4019 => ::std::option::Option::Some(ExploreMsgId::MsgIdFoodNumReq),
            4020 => ::std::option::Option::Some(ExploreMsgId::MsgIdFoodNumResp),
            4021 => ::std::option::Option::Some(ExploreMsgId::MsgIdRemoveBackpackReq),
            4022 => ::std::option::Option::Some(ExploreMsgId::MsgIdRemoveBackpackResp),
            4023 => ::std::option::Option::Some(ExploreMsgId::MsgIdGiveItemsReq),
            4024 => ::std::option::Option::Some(ExploreMsgId::MsgIdGiveItemsResp),
            4025 => ::std::option::Option::Some(ExploreMsgId::MsgIdTeamBuffReq),
            4026 => ::std::option::Option::Some(ExploreMsgId::MsgIdTeamBuffResp),
            4027 => ::std::option::Option::Some(ExploreMsgId::MsgIdWinReq),
            4028 => ::std::option::Option::Some(ExploreMsgId::MsgIdWinResp),
            4029 => ::std::option::Option::Some(ExploreMsgId::MsgIdDarkThunderReq),
            4030 => ::std::option::Option::Some(ExploreMsgId::MsgIdDarkThunderResp),
            4131 => ::std::option::Option::Some(ExploreMsgId::MsgIdMapStateSync),
            4132 => ::std::option::Option::Some(ExploreMsgId::MsgIdPortal),
            4200 => ::std::option::Option::Some(ExploreMsgId::MsgIdTaskSync),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExploreMsgId] = &[
            ExploreMsgId::ERROR_MSG_ID,
            ExploreMsgId::MsgIdCreateExploreReq,
            ExploreMsgId::MsgIdCreateExploreResp,
            ExploreMsgId::MsgIdKickOff,
            ExploreMsgId::MsgIdExploreMoveReq,
            ExploreMsgId::MsgIdExploreMoveResp,
            ExploreMsgId::MsgIdExploreEventReq,
            ExploreMsgId::MsgIdExploreEventResp,
            ExploreMsgId::MsgIdExploreSyncResp,
            ExploreMsgId::MsgIdExploreBattleResultReq,
            ExploreMsgId::MsgIdQuitExploreReq,
            ExploreMsgId::MsgIdQuitExploreResp,
            ExploreMsgId::MsgIdExploreBattleResultResp,
            ExploreMsgId::MsgIdCurrentEventReq,
            ExploreMsgId::MsgIdCurrentEventResp,
            ExploreMsgId::MsgIdMsgDropItemReq,
            ExploreMsgId::MsgIdMsgDropItemResp,
            ExploreMsgId::MsgIdUseItemReq,
            ExploreMsgId::MsgIdUseItemResp,
            ExploreMsgId::MsgIdFoodNumReq,
            ExploreMsgId::MsgIdFoodNumResp,
            ExploreMsgId::MsgIdRemoveBackpackReq,
            ExploreMsgId::MsgIdRemoveBackpackResp,
            ExploreMsgId::MsgIdGiveItemsReq,
            ExploreMsgId::MsgIdGiveItemsResp,
            ExploreMsgId::MsgIdTeamBuffReq,
            ExploreMsgId::MsgIdTeamBuffResp,
            ExploreMsgId::MsgIdWinReq,
            ExploreMsgId::MsgIdWinResp,
            ExploreMsgId::MsgIdDarkThunderReq,
            ExploreMsgId::MsgIdDarkThunderResp,
            ExploreMsgId::MsgIdMapStateSync,
            ExploreMsgId::MsgIdPortal,
            ExploreMsgId::MsgIdTaskSync,
        ];
        values
    }
}

impl ::std::marker::Copy for ExploreMsgId {
}

impl ::std::default::Default for ExploreMsgId {
    fn default() -> Self {
        ExploreMsgId::ERROR_MSG_ID
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreMsgId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExploreResult {
    FINISHED = 0,
    UNFINISHED = 1,
    FAILED = 2,
}

impl ::protobuf::ProtobufEnum for ExploreResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExploreResult> {
        match value {
            0 => ::std::option::Option::Some(ExploreResult::FINISHED),
            1 => ::std::option::Option::Some(ExploreResult::UNFINISHED),
            2 => ::std::option::Option::Some(ExploreResult::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExploreResult] = &[
            ExploreResult::FINISHED,
            ExploreResult::UNFINISHED,
            ExploreResult::FAILED,
        ];
        values
    }
}

impl ::std::marker::Copy for ExploreResult {
}

impl ::std::default::Default for ExploreResult {
    fn default() -> Self {
        ExploreResult::FINISHED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StartExploreResult {
    START_SUCCESS = 0,
    NO_EXPLORE_FOUND = 1,
}

impl ::protobuf::ProtobufEnum for StartExploreResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StartExploreResult> {
        match value {
            0 => ::std::option::Option::Some(StartExploreResult::START_SUCCESS),
            1 => ::std::option::Option::Some(StartExploreResult::NO_EXPLORE_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StartExploreResult] = &[
            StartExploreResult::START_SUCCESS,
            StartExploreResult::NO_EXPLORE_FOUND,
        ];
        values
    }
}

impl ::std::marker::Copy for StartExploreResult {
}

impl ::std::default::Default for StartExploreResult {
    fn default() -> Self {
        StartExploreResult::START_SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for StartExploreResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EAttributeType {
    None = 0,
    Attack = 1,
    Defense = 2,
    MaxHealth = 3,
    Health = 4,
    MaxActionPower = 5,
    ActionPower = 6,
    BaseMotionAbility = 7,
    MaxSun = 8,
    CurrentSun = 9,
    Critical = 10,
    CriticalPercent = 11,
    Resistance = 12,
    AdditionalDamage = 13,
    SufferDamage = 14,
    IgnoreDefense = 15,
    ElectricPower = 16,
    FranticValue = 17,
    HolyBookValue = 18,
    PeaceValue = 19,
    FuryValue = 20,
    SuckBlood = 21,
    MaxCount = 22,
}

impl ::protobuf::ProtobufEnum for EAttributeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAttributeType> {
        match value {
            0 => ::std::option::Option::Some(EAttributeType::None),
            1 => ::std::option::Option::Some(EAttributeType::Attack),
            2 => ::std::option::Option::Some(EAttributeType::Defense),
            3 => ::std::option::Option::Some(EAttributeType::MaxHealth),
            4 => ::std::option::Option::Some(EAttributeType::Health),
            5 => ::std::option::Option::Some(EAttributeType::MaxActionPower),
            6 => ::std::option::Option::Some(EAttributeType::ActionPower),
            7 => ::std::option::Option::Some(EAttributeType::BaseMotionAbility),
            8 => ::std::option::Option::Some(EAttributeType::MaxSun),
            9 => ::std::option::Option::Some(EAttributeType::CurrentSun),
            10 => ::std::option::Option::Some(EAttributeType::Critical),
            11 => ::std::option::Option::Some(EAttributeType::CriticalPercent),
            12 => ::std::option::Option::Some(EAttributeType::Resistance),
            13 => ::std::option::Option::Some(EAttributeType::AdditionalDamage),
            14 => ::std::option::Option::Some(EAttributeType::SufferDamage),
            15 => ::std::option::Option::Some(EAttributeType::IgnoreDefense),
            16 => ::std::option::Option::Some(EAttributeType::ElectricPower),
            17 => ::std::option::Option::Some(EAttributeType::FranticValue),
            18 => ::std::option::Option::Some(EAttributeType::HolyBookValue),
            19 => ::std::option::Option::Some(EAttributeType::PeaceValue),
            20 => ::std::option::Option::Some(EAttributeType::FuryValue),
            21 => ::std::option::Option::Some(EAttributeType::SuckBlood),
            22 => ::std::option::Option::Some(EAttributeType::MaxCount),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EAttributeType] = &[
            EAttributeType::None,
            EAttributeType::Attack,
            EAttributeType::Defense,
            EAttributeType::MaxHealth,
            EAttributeType::Health,
            EAttributeType::MaxActionPower,
            EAttributeType::ActionPower,
            EAttributeType::BaseMotionAbility,
            EAttributeType::MaxSun,
            EAttributeType::CurrentSun,
            EAttributeType::Critical,
            EAttributeType::CriticalPercent,
            EAttributeType::Resistance,
            EAttributeType::AdditionalDamage,
            EAttributeType::SufferDamage,
            EAttributeType::IgnoreDefense,
            EAttributeType::ElectricPower,
            EAttributeType::FranticValue,
            EAttributeType::HolyBookValue,
            EAttributeType::PeaceValue,
            EAttributeType::FuryValue,
            EAttributeType::SuckBlood,
            EAttributeType::MaxCount,
        ];
        values
    }
}

impl ::std::marker::Copy for EAttributeType {
}

impl ::std::default::Default for EAttributeType {
    fn default() -> Self {
        EAttributeType::None
    }
}

impl ::protobuf::reflect::ProtobufValue for EAttributeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EExploreEventType {
    NONE = 0,
    DIALOG = 1,
    DIALOG_CHOOSE = 2,
    CHOOSE = 3,
    ROLL = 4,
}

impl ::protobuf::ProtobufEnum for EExploreEventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EExploreEventType> {
        match value {
            0 => ::std::option::Option::Some(EExploreEventType::NONE),
            1 => ::std::option::Option::Some(EExploreEventType::DIALOG),
            2 => ::std::option::Option::Some(EExploreEventType::DIALOG_CHOOSE),
            3 => ::std::option::Option::Some(EExploreEventType::CHOOSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EExploreEventType] = &[
            EExploreEventType::NONE,
            EExploreEventType::DIALOG,
            EExploreEventType::DIALOG_CHOOSE,
            EExploreEventType::CHOOSE,
            EExploreEventType::ROLL,
        ];
        values
    }
}

impl ::std::marker::Copy for EExploreEventType {
}

impl ::std::default::Default for EExploreEventType {
    fn default() -> Self {
        EExploreEventType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for EExploreEventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExploreEventActionType {
    Cancel = 0,
    Select = 1,
    Activate = 2,
    Finish = 3,
    Reroll = 4,
}

impl ::protobuf::ProtobufEnum for ExploreEventActionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExploreEventActionType> {
        match value {
            0 => ::std::option::Option::Some(ExploreEventActionType::Cancel),
            1 => ::std::option::Option::Some(ExploreEventActionType::Select),
            2 => ::std::option::Option::Some(ExploreEventActionType::Activate),
            3 => ::std::option::Option::Some(ExploreEventActionType::Finish),
            4 => ::std::option::Option::Some(ExploreEventActionType::Reroll),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExploreEventActionType] = &[
            ExploreEventActionType::Cancel,
            ExploreEventActionType::Select,
            ExploreEventActionType::Activate,
            ExploreEventActionType::Finish,
            ExploreEventActionType::Reroll,
        ];
        values
    }
}

impl ::std::marker::Copy for ExploreEventActionType {
}

impl ::std::default::Default for ExploreEventActionType {
    fn default() -> Self {
        ExploreEventActionType::Cancel
    }
}

impl ::protobuf::reflect::ProtobufValue for ExploreEventActionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CEsResult {
    RR_SUCCESS = 0,
    RR_FAIL = 1,
    RR_NOT_GM = 2,
    RR_FULL = 3,
}

impl ::protobuf::ProtobufEnum for CEsResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CEsResult> {
        match value {
            0 => ::std::option::Option::Some(CEsResult::RR_SUCCESS),
            1 => ::std::option::Option::Some(CEsResult::RR_FAIL),
            2 => ::std::option::Option::Some(CEsResult::RR_NOT_GM),
            3 => ::std::option::Option::Some(CEsResult::RR_FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CEsResult] = &[
            CEsResult::RR_SUCCESS,
            CEsResult::RR_FAIL,
            CEsResult::RR_NOT_GM,
            CEsResult::RR_FULL,
        ];
        values
    }
}

impl ::std::marker::Copy for CEsResult {
}

impl ::std::default::Default for CEsResult {
    fn default() -> Self {
        CEsResult::RR_SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for CEsResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
